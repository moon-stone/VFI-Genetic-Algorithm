package makespanTest;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.Random;
import java.util.Queue;
import java.util.LinkedList;

public class Main {
	public int population_size, stoping_cond, pair1, pair2;
	public double mutation_rate, crossover_rate;
	public int no_of_subtasks,  no_of_machines, min_fv = 999999999, counter;
	public Scanner in_,  inheft_;
	public PrintStream out_;
	public int[] basic_ss, subtask_to_processor, processor_to_island;
	public int[][] est, rel, island_to_processor, predecessor_mat;
	public float[][] voltage_pair1, voltage_pair2;
	public int[] degree, start_time, end_time, processor_avail_time;
	LinkedList<Integer>[] available_slot;
	public Main(String file_name) throws IOException{
		in_ = new Scanner(new FileInputStream(file_name));
		
		///------------------taking input from file--------------------
		
		//finding no of processor
		while(true){
			if(in_.next().compareTo("No_of_Processor") == 0){
				no_of_machines = in_.nextInt();
				break;
			}
		}
		System.out.println("no. of machines " +no_of_machines);
		
		//finding no of subtasks
		while(true){
			if(in_.next().compareTo("t_nst") == 0){
				no_of_subtasks = in_.nextInt();
				break;
			}
		}
		System.out.println("no. of subtask " +no_of_subtasks);
		
		
		est = new int[no_of_subtasks][no_of_machines];
		rel = new int[no_of_subtasks][no_of_subtasks];
		island_to_processor = new int[2][no_of_machines];
		predecessor_mat = new int [no_of_subtasks][no_of_subtasks];
		start_time = new int[no_of_subtasks];
		end_time = new int[no_of_subtasks];
		processor_avail_time = new int[no_of_machines];
		subtask_to_processor = new int[no_of_subtasks];
		processor_to_island = new int[no_of_machines];
		available_slot = new LinkedList[no_of_machines];
		for (int i=0; i < no_of_machines; i++) {
		    available_slot[i] = new LinkedList<Integer>();
		    available_slot[i].add(0);
		    available_slot[i].add(20);
		}
		for(int i = 0; i < no_of_machines; i++) {
			System.out.print(available_slot[i].get(0));
		}
		//estimated cost matrix
		for (int i = 0; i < no_of_subtasks; i++) {
			in_.next();
			for (int j = 0; j < no_of_machines; j++) {
				est[i][j] = in_.nextInt();
				System.out.print(est[i][j] + " ");
			}
			System.out.println();
		}
		int x, y, w;
		while (true) {
			if (in_.next().compareTo("task_end") == 0) {
				in_.nextLine();
				break;
			}
			x = in_.nextInt();
			y = in_.nextInt();
			w = in_.nextInt();
			rel[x][y] = w;
		}
		
		//communication cost matrix
		System.out.println("Communication cost matrix" + " ");
		for (int i = 0; i < no_of_subtasks; i++) {
			for (int j = 0; j < no_of_subtasks; j++) {
				System.out.print(rel[i][j] + " ");
				if(rel[i][j] != 0) {
					predecessor_mat[j][i] = 1;
				}
			}
			System.out.println();
		}
		
		//finding number of voltage pairs in pair1 for island0

		while(true){
			if(in_.next().compareTo("Pair1") == 0){
				pair1 = in_.nextInt();
				break;
			}
		}
		System.out.println("Volatage pairs for Island0 are "+ pair1);
		voltage_pair1 = new float[pair1][2];
		for(int i = 0; i < pair1; i++) {
			in_.next();
			
			voltage_pair1[i][0] = in_.nextFloat();
			voltage_pair1[i][1] = in_.nextInt();
			System.out.print(voltage_pair1[i][0] + " ");
			System.out.print(voltage_pair1[i][1] + " ");
			System.out.println();		
		}
		
		//finding number of voltage pairs in pair2 for island1
		while(true){
			if(in_.next().compareTo("Pair2") == 0){
				pair2 = in_.nextInt();
				break;
			}
		}
		voltage_pair2 = new float[pair2][2];
		System.out.println("Voltage pairs for island1 are "+ pair2);
		for(int i = 0; i < pair2; i++) {
			in_.next();
			voltage_pair2[i][0] = in_.nextFloat();
			voltage_pair2[i][1] = in_.nextInt();
			System.out.print(voltage_pair2[i][0] + " ");
			System.out.print(voltage_pair2[i][1] + " ");
			System.out.println();		
		}
		
		
	//	System.out.println(".....................................................................");
	    
		//processor to island(we are making only two island) mapping
	//	Map<Integer, Integer> processor_to_island = new HashMap<Integer, Integer>();
		for(int i = 0; i < no_of_machines; i++) {
			processor_to_island[i] = i%2;
			island_to_processor[i%2][i] = 1;
		}
		
		System.out.println("Machine to island mapping");
		
		for(int i = 0; i < no_of_machines; i++) {
			System.out.println("processor " + i + " mapped " + 
		    processor_to_island[i] + " island");
		}
		
		System.out.println("Island to processor mapping");
		for(int i = 0; i < 2; i++) {
			System.out.print("Island " + i + " have these machines = ");
			for(int j = 0; j < no_of_machines; j++) {
				if(island_to_processor[i][j] == 1) {
					System.out.print(j + " ");
				}
			}
			System.out.println();
		}
		
		//changing estimated cost to for two island...making odd and even columns equal
		System.out.println("Making execution cost of processors in island equal");
		for(int i = 0; i < no_of_machines; i++) {
			for(int j = 0; j < no_of_subtasks; j++) {
				est[j][i] = est[j][processor_to_island[i]];
			}
		}
		
		//printing changed estimated cost
		for (int i = 0; i < no_of_subtasks; i++) {
			for (int j = 0; j < no_of_machines; j++) {
				System.out.print(est[i][j] + " ");
			}
			System.out.println();
		}
		
		Random rand = new Random();
		Map<Integer, Integer> sub_task_to_island = new HashMap<Integer, Integer>();
		
		//randomly alloting islands to the subtasks
		System.out.println("Randomly allocating subtasks to islands");
		for(int i = 0; i < no_of_subtasks; i++) {
			int rand_no = rand.nextInt(2);
			sub_task_to_island.put(i, rand_no);
		}
		 for (Map.Entry<Integer, Integer> set :
             sub_task_to_island.entrySet()) {
 
            // Printing all allocation of subtask to island
            System.out.println(set.getKey() + " = "
                               + set.getValue());
         }
		 
		 
		 int [] visited = new int[no_of_subtasks];
		 degree = new int[no_of_subtasks];
		 int [] temp_degree = new int[no_of_subtasks];
		 for(int i = 0; i < no_of_subtasks; i++) {
			 int count = 0;
			 for(int j = 0; j < no_of_subtasks; j++) {
				 if(rel[j][i] != 0) {
					 count++;
				 }
			 }
			 degree[i] = count;
		 }
		 for(int i = 0; i < no_of_subtasks; i++) {
			 temp_degree[i] = degree[i];
		 }
		 
		 //checking indegree of each vertex
		 System.out.println("Indegree of each subtask");
		 for(int i = 0; i < no_of_subtasks; i++) {
			 System.out.println(i + " " + degree[i]);
		 }
		 
		 System.out.println("Predecessor of each subtask in DAG");
		 for(int i = 0; i < no_of_subtasks; i++) {
			 System.out.print("Subtasks " + i + " predecessor = ");
			 for(int j = 0; j < no_of_subtasks; j++) {
				 if(predecessor_mat[i][j] == 1) {
					 System.out.print(j + " ");
				 }
			 }
			 System.out.println();
		 }
		 
		 basic_ss = new int[no_of_subtasks];
		 int ind = 0;
		 //generating initial valid schedule string through topological sort
		 for(int i = 0; i < no_of_subtasks; i++) {
			 for(int j = 0; j < no_of_subtasks; j++) {
				 if(temp_degree[j] == 0 && visited[j] == 0) {
					 basic_ss[ind++] = j;
					 visited[j] = 1;
					 for(int k = 0; k < no_of_subtasks; k++) {
						 if(rel[j][k] != 0) {
							 temp_degree[k]--;
						 }
					 }
				 }
			 }
			 
		 }
		 
		 System.out.println("Initial valid schedule string");
		 for(int i = 0; i < no_of_subtasks; i++) {
			 System.out.print(basic_ss[i] + " ");
			 visited[i] = 0;
		 }
		 
		 //checking given string is valid schedule string or not
		 System.out.println(check_valid_order(basic_ss) + " " + "ss");
		  
		 //taking indegree variable to use indegree frequently
		 int[] in_degree = new int[no_of_subtasks];
		 for(int i = 0; i < no_of_subtasks; i++) {
			 in_degree[i] = degree[i];
		 }
		
		 //calculating start time and finish time of each task by using
		 //execution cost and communication cost 
		 int entry_task = 0;
		 for(int i = 0; i < no_of_subtasks; i++) {
			 if(degree[i] == 0) {
				 entry_task = i;
				 break;
			 }
		 }
		 Queue<Integer> q = new LinkedList<>();
		 q.add(entry_task);
		 visited[entry_task] = 1;
		 while(!q.isEmpty()) {
			 int node = q.peek();
			 q.remove();
			 //decreasing indegree of all vertices dependent on node
			 for(int i = 0; i < no_of_subtasks; i++) {
				 if(rel[node][i] != 0) {
					 in_degree[i]--;
				 }
			 }
			 for(int i = 0; i < no_of_subtasks; i++) {
				 if(in_degree[i] == 0 && visited[i] == 0) {
					 q.add(i);
					 visited[i] = 1;
				 }
			 }
	         
			 //calculation expected time at which sub task can be allocated to processor
		/*	 int expected_allocation_time = 0;
			 for(int i = 0; i < no_of_subtasks; i++) {
				 if(predecessor_mat[node][i] == 1) {
					 expected_allocation_time = 
							 Math.max(expected_allocation_time, end_time[i] + rel[i][node]);
				 }
			 }  */
			 
			 int temp_island = sub_task_to_island.get(node);
			// System.out.println(node + " " + temp_island);
			 int flag = 0, min_time = Integer.MAX_VALUE;
			 int expected_allocation_time = 0;
			 int temp_processor = 0;
			 for(int i = 0; i < no_of_subtasks; i++) {
				 //we are going to find a processor where node's predecessor
				 //allocated so that communication time can be ignored for one
				 //predecessor atleast.
				 if(predecessor_mat[node][i] == 1) {
					 temp_processor = subtask_to_processor[i];
					 if(processor_to_island[temp_processor] == temp_island && 
						processor_avail_time[temp_processor] <= end_time[i]) {
						 flag = 1;
						 expected_allocation_time = expected_min_allocation_time(node, i);
						 processor_avail_time[temp_processor] = expected_allocation_time + 
								 est[node][temp_processor];
						 subtask_to_processor[node] = temp_processor;
						 start_time[node] = expected_allocation_time;
						 end_time[node] = start_time[node] + 
								 est[node][temp_processor];
						 break;
					 }
					 
				 }
			 }
			 if(flag == 0) {
				 expected_allocation_time = expected_min_allocation_time(node, node);
				 for(int i = 0; i < no_of_machines; i++) {
					 if(processor_to_island[i] == temp_island && 
					    processor_avail_time[i] < min_time) {
						 min_time = processor_avail_time[i];
						 temp_processor = i;
					 }
				 }
				 if(min_time > expected_allocation_time) {
					 expected_allocation_time = min_time;
				 }
				 processor_avail_time[temp_processor] = expected_allocation_time + 
						 est[node][temp_processor];
				 subtask_to_processor[node] = temp_processor;
				 start_time[node] = expected_allocation_time;
				 end_time[node] = start_time[node] + 
						 est[node][temp_processor];
			 
			 }
			 
			 
		 }
		 for(int i = 0; i < no_of_subtasks; i++) {
			 System.out.println(i + "th subtask start and end time with processor no. = " + start_time[i] + " " + 
		             end_time[i] + " " + subtask_to_processor[i]);
		 }
		 
		
	}
	
	public boolean check_valid_order(int []temp_ss) {
		
		int[] in_degree = new int[no_of_subtasks];
		int[] visited = new int[no_of_subtasks];
		for(int i = 0; i < no_of_subtasks; i++) {
			in_degree[i] = degree[i];
		}
		
		for(int i = 0; i < no_of_subtasks; i++) {
			int k = temp_ss[i];
			
			visited[k] = 1;
			for(int j = 0; j < no_of_subtasks; j++) {
				if(rel[k][j] != 0 && visited[j] == 0) {
					in_degree[j]--;
				}
			}
		}
	//	for(int i = 0; i < no_of_subtasks; i++) {
	//		System.out.print(in_degree[i] + " ");
	//	}
		
		for(int i = 0; i < no_of_subtasks; i++) {
			if(in_degree[i] != 0) {
			//	System.out.println(i + " " + in_degree[i]);
				return false;
			}
		}
		return true;
	}
	
	//expected allocation time at which all the details from its predecessors
	//are available.
	public int expected_min_allocation_time(int node, int predecessor_subtask) {
		int max_time = 0;
		for(int i = 0; i < no_of_subtasks; i++) {
			if(predecessor_mat[node][i] == 1 && i != predecessor_subtask) {
				max_time = Math.max(max_time , end_time[i]+rel[i][node]);
			}
			else if(predecessor_mat[node][i] == 1 && i == predecessor_subtask) {
				max_time = Math.max(max_time, end_time[i]);
			}
			
			
		}
		return max_time;
	}
	public int execution_time(int processor, int subtask) {
		int expected_start_time = est[subtask][processor];
		
		
		return 0;
	}
}
